# MVP App (Swift, UIKit)
Учебное iOS-приложение на Swift + UIKit, реализованное с использованием архитектурного паттерна MVP (Model–View–Presenter).
Проект состоит из двух экранов и может использоваться как пример для изучения MVP, роутинга и базовой сетевой логики.
Приложение загружает список изображений собак с публичного API и отображает их в таблице. При выборе элемента открывается экран с выбранным изображением.

Dog API: https://dog.ceo/dog-api/documentation/breed
* Возможно, понадобится включить VPN, если данные не будут загружаться

# Архитектура
В проекте используется MVP (Model–View–Presenter) с дополнительным слоем Router и Builder.

# Model

struct MainModel: Codable {
    let message: [String]
    let status: String
}
Отвечает за данные из сети.
message — массив URL изображений.

#  View
MainViewController — отображает таблицу с картинками и названиями.
MainTableViewCell — кастомная ячейка для таблицы.
DogViewController — экран для отображения выбранного изображения.

Зачем: View отвечает только за UI, а Presenter управляет логикой.

# Presenter
MainPresenter — получает данные через NetworkService, передаёт их во View, управляет кэшем изображений через ImageLoaderService.
DogPresenter — показывает выбранное изображение.

Зачем: Presenter отделяет бизнес-логику от UI.

#  Services
NetworkService — загрузка данных из сети.
ImageLoaderService — загрузка и кэширование изображений.
NSCache используется в ImageLoaderService.

Зачем NSCache:
 - Это встроенный класс для кэширования объектов в памяти.
 - Быстрый доступ к ранее загруженным изображениям.
 - Автоматически очищает старые объекты при нехватке памяти.
 - Отличается от словаря (Dictionary) тем, что безопасен для больших данных и экономит память.

#  Router / Builder
BaseBuilder — создаёт все ViewController с их Presenter и сервисами.
MainRouter — отвечает за навигацию между экранами.

Зачем:
 - Builder делает код более гибким для тестирования — можно подставлять моки вместо настоящих сервисов.
 - Router отделяет навигацию от Presenter и View.

# Кэширование изображений
Принцип работы:
1) При загрузке изображения проверяем NSCache.
2) Если изображение есть в кэше — используем его.
3) Если нет — скачиваем через сеть, сохраняем в кэш и показываем.

Преимущества:
 - Быстрая подгрузка повторно открываемых изображений.
 - Меньше сетевых запросов → экономия трафика и ресурсов.
 - Автоматическое управление памятью системой.

https://github.com/user-attachments/assets/97dc2154-18dd-425a-a124-24a88527eee8


